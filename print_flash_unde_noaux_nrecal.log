Namespace(abs_obj='NODE', all=True, cmp=False, confidence=1.0, iter=2, kmax=3, learn=False, node_num=2, outputfile=None, preprocess=False, protocol='flash_unde_noaux', recalculate='n', srcfile=None, support=0.0)
******************************
Preprocessing
typedef:
self.atoms:
collect atoms from NI_Replace3
self.atoms:
collect atoms from NI_Replace4
self.atoms:
collect atoms from NI_InvAck_311
self.atoms:
collect atoms from NI_InvAck_212
self.atoms:
collect atoms from NI_InvAck_113
self.atoms:
collect atoms from NI_InvAck_exists14
self.atoms:
collect atoms from NI_InvAck_exists_Home15
self.atoms:
collect atoms from NI_Inv16
self.atoms:
collect atoms from NI_Inv17
self.atoms:
collect atoms from NI_Remote_PutX18
self.atoms:
collect atoms from NI_Remote_Put20
self.atoms:
collect atoms from NI_Remote_Put21
self.atoms:
collect atoms from NI_Remote_GetX_PutX_Home24
self.atoms:
collect atoms from NI_Remote_GetX_PutX25
self.atoms:
collect atoms from NI_Remote_GetX_Nak_Home26
self.atoms:
collect atoms from NI_Remote_GetX_Nak27
self.atoms:
collect atoms from NI_Local_GetX_PutX_1128
self.atoms:
collect atoms from NI_Local_GetX_PutX_1029
self.atoms:
collect atoms from NI_Local_GetX_PutX_10_Home30
self.atoms:
collect atoms from NI_Local_GetX_PutX_931
self.atoms:
collect atoms from NI_Local_GetX_PutX_932
self.atoms:
collect atoms from NI_Local_GetX_PutX_8_NODE_Get33
self.atoms:
collect atoms from NI_Local_GetX_PutX_834
self.atoms:
collect atoms from NI_Local_GetX_PutX_8_Home_NODE_Get35
self.atoms:
collect atoms from NI_Local_GetX_PutX_8_Home36
self.atoms:
collect atoms from NI_Local_GetX_PutX_7_NODE_Get37
self.atoms:
collect atoms from NI_Local_GetX_PutX_7_NODE_Get38
self.atoms:
collect atoms from NI_Local_GetX_PutX_739
self.atoms:
collect atoms from NI_Local_GetX_PutX_740
self.atoms:
collect atoms from NI_Local_GetX_PutX_641
self.atoms:
collect atoms from NI_Local_GetX_PutX_542
self.atoms:
collect atoms from NI_Local_GetX_PutX_443
self.atoms:
collect atoms from NI_Local_GetX_PutX_344
self.atoms:
collect atoms from NI_Local_GetX_PutX_245
self.atoms:
collect atoms from NI_Local_GetX_PutX_146
self.atoms:
collect atoms from NI_Local_GetX_GetX47
self.atoms:
collect atoms from NI_Local_GetX_GetX48
self.atoms:
collect atoms from NI_Local_GetX_Nak49
self.atoms:
collect atoms from NI_Local_GetX_Nak50
self.atoms:
collect atoms from NI_Local_GetX_Nak51
self.atoms:
collect atoms from NI_Remote_Get_Put_Home52
self.atoms:
collect atoms from NI_Remote_Get_Put53
self.atoms:
collect atoms from NI_Remote_Get_Nak_Home54
self.atoms:
collect atoms from NI_Remote_Get_Nak55
self.atoms:
collect atoms from NI_Local_Get_Put_Dirty56
self.atoms:
collect atoms from NI_Local_Get_Put57
self.atoms:
collect atoms from NI_Local_Get_Put_Head58
self.atoms:
collect atoms from NI_Local_Get_Get59
self.atoms:
collect atoms from NI_Local_Get_Get60
self.atoms:
collect atoms from NI_Local_Get_Nak61
self.atoms:
collect atoms from NI_Local_Get_Nak62
self.atoms:
collect atoms from NI_Local_Get_Nak63
self.atoms:
collect atoms from NI_Nak66
self.atoms:
collect atoms from PI_Remote_Replace68
self.atoms:
collect atoms from PI_Remote_PutX71
self.atoms:
collect atoms from PI_Remote_GetX80
self.atoms:
collect atoms from PI_Remote_Get84
self.atoms:
collect atoms from Store_Home85
self.atoms:
collect atoms from Store86
Find atomic predicates: 55

all_types:{'NODE': 'NODE_NUM', 'DATA': 'DATA_NUM'}
[({'Sta.UniMsg[NODE_2].Cmd = UNI_Nak', 'Sta.Dir.ShrSet[NODE_1] = true'}, 'Sta.Dir.InvSet[NODE_2] = false'), ({'Sta.WbMsg.Cmd = WB_Wb'}, 'Sta.InvMsg[NODE_1].Cmd != INV_Inv')]
******************************
Recheck rules by murphi


[Rulename]: NI_Replace3
guard:{'Sta.RpMsg[NODE_1].Cmd = RP_Replace', 'Sta.Dir.ShrVld'}
Strengthening 1 time, find 7 predicates

include 1 abstract type

Rule NI_Replace3 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Replace3: 4
string_list:['Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: NI_Replace4
guard:{'Sta.RpMsg[NODE_1].Cmd = RP_Replace', '!Sta.Dir.ShrVld'}
Strengthening 1 time, find 7 predicates

include 1 abstract type

Rule NI_Replace4 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Replace4: 4
string_list:['Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.RpMsg[NODE_1].Cmd = RP_Replace -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: NI_InvAck_311
{'src': 'NODE_1', 'p': 'NODE_2'} {'p': 'NODE', 'src': 'NODE'}
guard:{'Sta.Dir.InvSet[NODE_1] = true', 'Sta.Dir.Dirty = true', 'Sta.Dir.HomeInvSet = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck', 'NODE_2 = NODE_1 | Sta.Dir.InvSet[NODE_2] = false', 'Sta.Dir.Pending = true'}
Strengthening 1 time, find 35 predicates

include 1 abstract type

Rule NI_InvAck_311 has 1 parameter.

Print abstract rule of NI_InvAck_311, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_InvAck_311_NODE_1"

	Sta.Dir.Pending = true &
	Sta.Dir.Dirty = true &
	Sta.Dir.HomeInvSet = false
	& forall NODE_2 : NODE do
			NODE_2 = Other | Sta.Dir.InvSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.Local = true &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_InvAck_311_NODE_1"

	Sta.Dir.Pending = true &
	Sta.Dir.Dirty = true &
	Sta.Dir.HomeInvSet = false
	& forall NODE_2 : NODE do
			NODE_2 = Other | Sta.Dir.InvSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.Local = true &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := false;
-- Auxiliary invariants used by NI_InvAck_311: 37
string_list:['Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Pending = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrVld = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr = NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.Local = true', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Local = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Dirty = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Dir.Dirty = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Local = true', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = true', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.ShrVld = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.MemData = Sta.CurrData', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = false', 'Sta.Dir.Dirty = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadVld = false']


[Rulename]: NI_InvAck_212
{'src': 'NODE_1', 'p': 'NODE_2'} {'p': 'NODE', 'src': 'NODE'}
guard:{'Sta.Dir.InvSet[NODE_1] = true', 'Sta.Dir.Local = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck', 'Sta.Dir.HomeInvSet = false', 'Sta.Dir.Pending = true', 'NODE_2 = NODE_1 |\n    Sta.Dir.InvSet[NODE_2] = false'}
Strengthening 1 time, find 37 predicates

include 1 abstract type

Rule NI_InvAck_212 has 1 parameter.

Print abstract rule of NI_InvAck_212, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_InvAck_212_NODE_1"

	Sta.Dir.Pending = true &
	Sta.Dir.Local = false &
	Sta.Dir.HomeInvSet = false
	& forall NODE_2 : NODE do
			NODE_2 = Other |
    Sta.Dir.InvSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.Local = true &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_InvAck_212_NODE_1"

	Sta.Dir.Pending = true &
	Sta.Dir.Local = false &
	Sta.Dir.HomeInvSet = false
	& forall NODE_2 : NODE do
			NODE_2 = Other |
    Sta.Dir.InvSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.Local = true &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := false;
-- Auxiliary invariants used by NI_InvAck_212: 40
string_list:['Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Pending = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrVld = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr = NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.Local = true', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Local = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.Local = false & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Dirty = false', 'Sta.Dir.Local = false & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Dirty = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Dir.Local = false & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Pending = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.Local = false & Sta.Dir.InvSet[NODE_1] = true -> Sta.MemData = Sta.CurrData', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = true', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.ShrVld = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.MemData = Sta.CurrData', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Dir.Local = false & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.ShrVld = true', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadVld = false']


[Rulename]: NI_InvAck_113
{'src': 'NODE_1', 'p': 'NODE_2'} {'p': 'NODE', 'src': 'NODE'}
guard:{'Sta.Dir.InvSet[NODE_1] = true', 'Sta.Dir.HomeInvSet = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck', 'Sta.Dir.Pending = true', 'Sta.Dir.Local = true', 'NODE_2 = NODE_1 |\n    Sta.Dir.InvSet[NODE_2] = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 35 predicates

include 1 abstract type

Rule NI_InvAck_113 has 1 parameter.

Print abstract rule of NI_InvAck_113, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_InvAck_113_NODE_1"

	Sta.Dir.Pending = true &
	Sta.Dir.Local = true &
	Sta.Dir.Dirty = false &
	Sta.Dir.HomeInvSet = false
	& forall NODE_2 : NODE do
			NODE_2 = Other |
    Sta.Dir.InvSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_InvAck_113_NODE_1"

	Sta.Dir.Pending = true &
	Sta.Dir.Local = true &
	Sta.Dir.Dirty = false &
	Sta.Dir.HomeInvSet = false
	& forall NODE_2 : NODE do
			NODE_2 = Other |
    Sta.Dir.InvSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := false ;
	Sta.Dir.Local := false;
-- Auxiliary invariants used by NI_InvAck_113: 32
string_list:['Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Pending = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = true', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.ShrVld = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.MemData = Sta.CurrData', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadVld = false']


[Rulename]: NI_InvAck_exists14
guard:{'Sta.Dir.InvSet[NODE_1]', 'Sta.Dir.InvSet[NODE_2] = true', 'Sta.Dir.Pending = true', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck', 'NODE_1 != NODE_2'}
Strengthening 1 time, find 35 predicates

include 2 abstract type

Rule NI_InvAck_exists14 has 2 parameter.

Print abstract rule of NI_InvAck_exists14, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_InvAck_exists14_NODE_1"

	Sta.InvMsg[NODE_2].Cmd = INV_InvAck &
	Sta.Dir.Pending = true &
	Sta.Dir.InvSet[NODE_2] = true &
	Other != NODE_2
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.Local = true &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.Dir.ShrSet[NODE_2] = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_InvAck_exists14_NODE_1"

	Sta.InvMsg[NODE_2].Cmd = INV_InvAck &
	Sta.Dir.Pending = true &
	Sta.Dir.InvSet[NODE_2] = true &
	Other != NODE_2
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.Pending = false &
		Sta.Dir.HeadVld = true &
		Sta.Dir.ShrVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.Local = true &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.Dir.ShrSet[NODE_2] = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.InvMsg[NODE_2].Cmd := INV_None ;
	Sta.Dir.InvSet[NODE_2] := false;
action part is empty
action part is empty
-- Auxiliary invariants used by NI_InvAck_exists14: 35
string_list:['Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.HeadVld = true', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.HeadVld = false', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.UniMsg[NODE_1].Cmd != UNI_PutX', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.UniMsg[NODE_1].Cmd != UNI_PutX', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.HeadPtr = NODE_2', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.Local = true', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.HeadPtr != NODE_2', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.ShrVld = false', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.UniMsg[NODE_1].Proc != NODE_2', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.Dirty = false', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.Pending = false', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.MemData = Sta.CurrData', 'Sta.Dir.InvSet[NODE_2] = true & Sta.Dir.Pending = true -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.ShrVld = true', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_2] = true & Sta.Dir.Pending = true -> Sta.Dir.Local = true', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.HeadPtr = NODE_2', 'Sta.InvMsg[NODE_2].Cmd = INV_InvAck -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.InvSet[NODE_2] = true -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: NI_InvAck_exists_Home15
guard:{'Sta.Dir.Pending = true', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck', 'Sta.Dir.InvSet[NODE_1] = true', 'Sta.Dir.HomeInvSet'}
Strengthening 1 time, find 35 predicates

include 1 abstract type

Rule NI_InvAck_exists_Home15 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_InvAck_exists_Home15: 35
string_list:['Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Pending = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrVld = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr = NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.Local = true', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Local = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.Dirty = false', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = true', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.ShrVld = true', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.MemData = Sta.CurrData', 'Sta.Dir.InvSet[NODE_1] = true -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Dir.Pending = true & Sta.Dir.InvSet[NODE_1] = true -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_InvAck -> Sta.Dir.HeadVld = false']


[Rulename]: NI_Inv16
guard:{'Sta.Proc[NODE_1].ProcCmd = NODE_Get', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv'}
Strengthening 1 time, find 27 predicates

include 1 abstract type

Rule NI_Inv16 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Inv16: 20
string_list:['Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.Local = true', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.ShrVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].ProcCmd = NODE_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].ProcCmd = NODE_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.HeadPtr = NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Proc[NODE_1].ProcCmd = NODE_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Proc[NODE_1].ProcCmd = NODE_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.Pending = true']


[Rulename]: NI_Inv17
guard:{'Sta.InvMsg[NODE_1].Cmd = INV_Inv', 'Sta.Proc[NODE_1].ProcCmd != NODE_Get'}
Strengthening 1 time, find 27 predicates

include 1 abstract type

Rule NI_Inv17 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Inv17: 20
string_list:['Sta.Proc[NODE_1].ProcCmd != NODE_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.Local = true', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.ShrVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Proc[NODE_1].ProcCmd != NODE_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.HeadPtr != NODE_2', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.HeadVld = false', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.HeadPtr = NODE_1', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Proc[NODE_1].ProcCmd != NODE_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.InvMsg[NODE_1].Cmd = INV_Inv -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].ProcCmd != NODE_Get -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Remote_PutX18
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_PutX', 'Sta.Proc[NODE_1].ProcCmd = NODE_GetX'}
Strengthening 1 time, find 42 predicates

include 1 abstract type

Rule NI_Remote_PutX18 has 1 parameter.
stmt:Sta.Proc[NODE_1].CacheData := Sta.UniMsg[NODE_1].Data,assign:Sta.UniMsg[NODE_1].Data,rep_dict[assign]:Sta.CurrData
stmt:Sta.Proc[NODE_1].CacheData := Sta.CurrData
action part is empty
-- Auxiliary invariants used by NI_Remote_PutX18: 31
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.Local = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.HeadPtr = NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].ProcCmd = NODE_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.HeadVld = true', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].ProcCmd = NODE_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].ProcCmd = NODE_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.Dirty = true', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.ShrVld = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.HeadPtr = NODE_2', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_PutX -> Sta.Dir.Pending = true']


[Rulename]: NI_Remote_Put20
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Put', 'Sta.Proc[NODE_1].InvMarked'}
Strengthening 1 time, find 18 predicates

include 1 abstract type

Rule NI_Remote_Put20 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Remote_Put20: 9
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.Proc[NODE_2].CacheState != CACHE_E']


[Rulename]: NI_Remote_Put21
guard:{'!Sta.Proc[NODE_1].InvMarked', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put'}
Strengthening 1 time, find 18 predicates

include 1 abstract type

Rule NI_Remote_Put21 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Remote_Put21: 9
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Put -> Sta.Proc[NODE_2].CacheState != CACHE_E']


[Rulename]: NI_Remote_GetX_PutX_Home24
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_E', 'Sta.HomeUniMsg.Cmd = UNI_GetX', 'Sta.HomeUniMsg.HomeProc = false', 'Sta.HomeUniMsg.Proc = NODE_1'}
Strengthening 1 time, find 42 predicates

include 1 abstract type

Rule NI_Remote_GetX_PutX_Home24 has 1 parameter.
stmt:Sta.HomeUniMsg.Data := Sta.Proc[NODE_1].CacheData,assign:Sta.Proc[NODE_1].CacheData,rep_dict[assign]:Sta.CurrData
stmt:Sta.HomeUniMsg.Data := Sta.CurrData

Print abstract rule of NI_Remote_GetX_PutX_Home24, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_GetX_PutX_Home24_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_GetX &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Remote_GetX_PutX_Home24_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_GetX &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.HomeUniMsg.Cmd := UNI_PutX ;
	Sta.HomeUniMsg.Data := Sta.CurrData;
-- Auxiliary invariants used by NI_Remote_GetX_PutX_Home24: 27
string_list:['Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Local = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadVld = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Dirty = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_2']


[Rulename]: NI_Remote_GetX_PutX25
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_E', 'NODE_2 != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX', 'Sta.UniMsg[NODE_2].HomeProc = false'}
Strengthening 1 time, find 52 predicates

include 2 abstract type

Rule NI_Remote_GetX_PutX25 has 2 parameter.
stmt:Sta.UniMsg[NODE_2].Data := Sta.Proc[NODE_1].CacheData,assign:Sta.Proc[NODE_1].CacheData,rep_dict[assign]:Sta.CurrData
stmt:Sta.UniMsg[NODE_2].Data := Sta.CurrData

Print abstract rule of NI_Remote_GetX_PutX25, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_GetX_PutX25_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadVld = false &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_GetX_PutX25_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadVld = false &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.UniMsg[NODE_2].Cmd := UNI_PutX ;
	Sta.UniMsg[NODE_2].Data := Sta.CurrData ;
	Sta.ShWbMsg.Cmd := SHWB_FAck ;
	Sta.ShWbMsg.Proc := NODE_2 ;
	Sta.ShWbMsg.HomeProc := false;

Print abstract rule of NI_Remote_GetX_PutX25, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_GetX_PutX25_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_GetX_PutX25_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.ShWbMsg.Cmd := SHWB_FAck ;
	Sta.ShWbMsg.Proc := Other ;
	Sta.ShWbMsg.HomeProc := false;

Print abstract rule of NI_Remote_GetX_PutX25, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_GetX_PutX25_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadVld = false &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:
rule "n_ABS_NI_Remote_GetX_PutX25_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadVld = false &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.ShWbMsg.Cmd := SHWB_FAck ;
	Sta.ShWbMsg.Proc := Other ;
	Sta.ShWbMsg.HomeProc := false;
-- Auxiliary invariants used by NI_Remote_GetX_PutX25: 63
string_list:['Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Local = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.UniMsg[NODE_1].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadVld = true', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.UniMsg[NODE_1].Cmd != UNI_Put', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Proc[NODE_1].CacheState = CACHE_I', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Proc != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Proc[NODE_1].InvMarked = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.Dirty = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.MemData = Sta.CurrData', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.Local = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.ShrVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.UniMsg[NODE_1].Proc != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Dirty = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Proc[NODE_1].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_2']


[Rulename]: NI_Remote_GetX_Nak_Home26
guard:{'Sta.HomeUniMsg.Cmd = UNI_GetX', 'Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.HomeUniMsg.HomeProc = false', 'Sta.HomeUniMsg.Proc = NODE_1'}
Strengthening 1 time, find 6 predicates

include 1 abstract type

Rule NI_Remote_GetX_Nak_Home26 has 1 parameter.

Print abstract rule of NI_Remote_GetX_Nak_Home26, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_GetX_Nak_Home26_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_GetX &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Dir.HeadPtr != NODE_1
	end
print_stringAfter:
rule "n_ABS_NI_Remote_GetX_Nak_Home26_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_GetX &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Dir.HeadPtr != NODE_1
	end
action:
	Sta.HomeUniMsg.Cmd := UNI_Nak ;
	Sta.NakcMsg.Cmd := NAKC_Nakc;
-- Auxiliary invariants used by NI_Remote_GetX_Nak_Home26: 4
string_list:['Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv']


[Rulename]: NI_Remote_GetX_Nak27
guard:{'NODE_2 != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX', 'Sta.UniMsg[NODE_2].Proc = NODE_1', 'Sta.UniMsg[NODE_2].HomeProc = false', 'Sta.Proc[NODE_1].CacheState != CACHE_E'}
Strengthening 1 time, find 35 predicates

include 2 abstract type

Rule NI_Remote_GetX_Nak27 has 2 parameter.

Print abstract rule of NI_Remote_GetX_Nak27, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_GetX_Nak27_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_GetX_Nak27_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.UniMsg[NODE_2].Cmd := UNI_Nak ;
	Sta.UniMsg[NODE_2].Proc := Other ;
	Sta.UniMsg[NODE_2].HomeProc := false ;
	Sta.NakcMsg.Cmd := NAKC_Nakc;

Print abstract rule of NI_Remote_GetX_Nak27, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_GetX_Nak27_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_GetX_Nak27_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.HeadVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.NakcMsg.Cmd := NAKC_Nakc;

Print abstract rule of NI_Remote_GetX_Nak27, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_GetX_Nak27_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadVld = false &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:
rule "n_ABS_NI_Remote_GetX_Nak27_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadVld = false &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.NakcMsg.Cmd := NAKC_Nakc;
-- Auxiliary invariants used by NI_Remote_GetX_Nak27: 39
string_list:['Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.UniMsg[NODE_1].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.UniMsg[NODE_1].Cmd != UNI_Put', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Proc[NODE_1].CacheState = CACHE_I', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Proc != NODE_1', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Proc[NODE_1].InvMarked = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.Dirty = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.MemData = Sta.CurrData', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.Local = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.Pending = true', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.ShrVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.UniMsg[NODE_1].Proc != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Proc[NODE_1].CacheState != CACHE_S', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_1128
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.Dir.Pending = false', 'Sta.Dir.Local = true', 'Sta.HomeProc.CacheState = CACHE_E', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX'}
Strengthening 1 time, find 26 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_1128 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_1128, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_1128_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = true &
	Sta.HomeProc.CacheState = CACHE_E
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_1128_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = true &
	Sta.HomeProc.CacheState = CACHE_E
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_1128: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_1029
guard:{'Sta.Dir.ShrSet[NODE_1]', 'Sta.Dir.Local = false', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX', 'Sta.Dir.HeadPtr = NODE_2', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_2].HomeProc', 'Sta.Dir.HomeHeadPtr = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 2 abstract type

Rule NI_Local_GetX_PutX_1029 has 2 parameter.

Print abstract rule of NI_Local_GetX_PutX_1029, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_1029_NODE_1"

	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].HomeProc &
	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = NODE_2 &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_1029_NODE_1"

	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].HomeProc &
	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = NODE_2 &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := NODE_2 ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != NODE_2 & ((Sta.Dir.ShrVld & Sta.Dir.ShrSet[p]) | ((Sta.Dir.HeadVld & Sta.Dir.HeadPtr = p) & Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.UniMsg[NODE_2].Cmd := UNI_PutX ;
	Sta.UniMsg[NODE_2].Data := Sta.MemData;

Print abstract rule of NI_Local_GetX_PutX_1029, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_1029_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE do
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_1029_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE do
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other & ((Sta.Dir.ShrVld & Sta.Dir.ShrSet[p]) | ((Sta.Dir.HeadVld & Sta.Dir.HeadPtr = p) & Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None;

Print abstract rule of NI_Local_GetX_PutX_1029, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_1029_NODE_1_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_1029_NODE_1_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other & ((Sta.Dir.ShrVld & Sta.Dir.ShrSet[p]) | ((Sta.Dir.HeadVld & Sta.Dir.HeadPtr = p) & Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None;
-- Auxiliary invariants used by NI_Local_GetX_PutX_1029: 6
string_list:['Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.HeadPtr = NODE_2 -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.Pending = false -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: NI_Local_GetX_PutX_10_Home30
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'Sta.Dir.HomeShrSet', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_10_Home30 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_10_Home30, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_10_Home30_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet &
	Sta.Dir.Local = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_10_Home30_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet &
	Sta.Dir.Local = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None;
-- Auxiliary invariants used by NI_Local_GetX_PutX_10_Home30: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_931
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 29 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_931 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_931, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_931_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr != Other &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_931_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr != Other &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None;
-- Auxiliary invariants used by NI_Local_GetX_PutX_931: 3
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_932
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.Dir.HomeHeadPtr = true', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_932 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_932, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_932_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HomeHeadPtr = true &
	Sta.Dir.Local = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_932_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HomeHeadPtr = true &
	Sta.Dir.Local = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None;
-- Auxiliary invariants used by NI_Local_GetX_PutX_932: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_8_NODE_Get33
guard:{'Sta.Dir.ShrSet[NODE_1]', 'Sta.HomeProc.ProcCmd = NODE_Get', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX', 'Sta.Dir.HeadPtr = NODE_2', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_2].HomeProc', 'Sta.Dir.HomeHeadPtr = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 2 abstract type

Rule NI_Local_GetX_PutX_8_NODE_Get33 has 2 parameter.

Print abstract rule of NI_Local_GetX_PutX_8_NODE_Get33, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_8_NODE_Get33_NODE_1"

	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].HomeProc &
	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = NODE_2 &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_8_NODE_Get33_NODE_1"

	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].HomeProc &
	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = NODE_2 &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := NODE_2 ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != NODE_2 &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.UniMsg[NODE_2].Cmd := UNI_PutX ;
	Sta.UniMsg[NODE_2].Data := Sta.MemData ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;

Print abstract rule of NI_Local_GetX_PutX_8_NODE_Get33, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_8_NODE_Get33_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_8_NODE_Get33_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;

Print abstract rule of NI_Local_GetX_PutX_8_NODE_Get33, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_8_NODE_Get33_NODE_1_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_8_NODE_Get33_NODE_1_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;
-- Auxiliary invariants used by NI_Local_GetX_PutX_8_NODE_Get33: 7
string_list:['Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.Local = true -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.HeadPtr = NODE_2 -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.Pending = false -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: NI_Local_GetX_PutX_834
guard:{'Sta.Dir.ShrSet[NODE_1]', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX', 'Sta.Dir.HeadPtr = NODE_2', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_2].HomeProc', 'Sta.Dir.HomeHeadPtr = false', 'Sta.HomeProc.ProcCmd != NODE_Get', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 2 abstract type

Rule NI_Local_GetX_PutX_834 has 2 parameter.

Print abstract rule of NI_Local_GetX_PutX_834, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_834_NODE_1"

	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].HomeProc &
	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = NODE_2 &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_834_NODE_1"

	Sta.UniMsg[NODE_2].Cmd = UNI_GetX &
	Sta.UniMsg[NODE_2].HomeProc &
	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = NODE_2 &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_1 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := NODE_2 ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != NODE_2 &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.UniMsg[NODE_2].Cmd := UNI_PutX ;
	Sta.UniMsg[NODE_2].Data := Sta.MemData ;
	Sta.HomeProc.CacheState := CACHE_I;

Print abstract rule of NI_Local_GetX_PutX_834, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_834_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Local_GetX_PutX_834_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I;

Print abstract rule of NI_Local_GetX_PutX_834, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_834_NODE_1_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_834_NODE_1_NODE_2"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Proc[NODE_2].ProcCmd != NODE_Get &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].ProcCmd = NODE_GetX &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_834: 7
string_list:['Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.Local = true -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.HeadPtr = NODE_2 -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX & Sta.Dir.Pending = false -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: NI_Local_GetX_PutX_8_Home_NODE_Get35
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.HomeProc.ProcCmd = NODE_Get', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'Sta.Dir.HomeShrSet', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_8_Home_NODE_Get35 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_8_Home_NODE_Get35, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_8_Home_NODE_Get35_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_8_Home_NODE_Get35_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;
-- Auxiliary invariants used by NI_Local_GetX_PutX_8_Home_NODE_Get35: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_8_Home36
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'Sta.Dir.HomeShrSet', 'Sta.HomeProc.ProcCmd != NODE_Get', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_8_Home36 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_8_Home36, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_8_Home36_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_8_Home36_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_8_Home36: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_7_NODE_Get37
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.HomeProc.ProcCmd = NODE_Get', 'Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.Pending = false', 'Sta.Dir.Local = true', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 29 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_7_NODE_Get37 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_7_NODE_Get37, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_7_NODE_Get37_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr != Other &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_7_NODE_Get37_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr != Other &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;
-- Auxiliary invariants used by NI_Local_GetX_PutX_7_NODE_Get37: 3
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_7_NODE_Get38
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.HomeProc.ProcCmd = NODE_Get', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HomeHeadPtr = true', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_7_NODE_Get38 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_7_NODE_Get38, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_7_NODE_Get38_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HomeHeadPtr = true &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_7_NODE_Get38_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HomeHeadPtr = true &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;
-- Auxiliary invariants used by NI_Local_GetX_PutX_7_NODE_Get38: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_739
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.Pending = false', 'Sta.Dir.Local = true', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.HomeProc.ProcCmd != NODE_Get', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 29 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_739 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_739, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_739_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr != Other &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_739_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HeadPtr != Other &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_739: 3
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_740
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadVld', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'Sta.HomeProc.ProcCmd != NODE_Get', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_740 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_740, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_740_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_740_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true ;
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	if ((p != Other &
    ((Sta.Dir.ShrVld &
    Sta.Dir.ShrSet[p]) |
    ((Sta.Dir.HeadVld &
    Sta.Dir.HeadPtr = p) &
    Sta.Dir.HomeHeadPtr = false)))) then
      Sta.Dir.InvSet[p] := true ;
	Sta.InvMsg[p].Cmd := INV_Inv ;
	else
      Sta.Dir.InvSet[p] := false ;
	Sta.InvMsg[p].Cmd := INV_None ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeInvMsg.Cmd := INV_None ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_740: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_641
{'src': 'NODE_1', 'p': 'NODE_2'} {'p': 'NODE', 'src': 'NODE'}
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'NODE_2 != NODE_1 ->\n    Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Dir.HomeShrSet = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_641 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_641, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_641_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet = false &
	Sta.Dir.Local = false
	& forall NODE_2 : NODE do
			NODE_2 != Other ->
    Sta.Dir.ShrSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_641_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet = false &
	Sta.Dir.Local = false
	& forall NODE_2 : NODE do
			NODE_2 != Other ->
    Sta.Dir.ShrSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_641: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_542
{'src': 'NODE_1', 'p': 'NODE_2'} {'p': 'NODE', 'src': 'NODE'}
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'NODE_2 != NODE_1 ->\n    Sta.Dir.ShrSet[NODE_2] = false', 'Sta.HomeProc.ProcCmd != NODE_Get', 'Sta.Dir.HomeShrSet = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_542 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_542, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_542_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
	& forall NODE_2 : NODE do
			NODE_2 != Other ->
    Sta.Dir.ShrSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_542_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
	& forall NODE_2 : NODE do
			NODE_2 != Other ->
    Sta.Dir.ShrSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_542: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_443
{'src': 'NODE_1', 'p': 'NODE_2'} {'p': 'NODE', 'src': 'NODE'}
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.HomeProc.ProcCmd = NODE_Get', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false', 'NODE_2 != NODE_1 ->\n    Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Dir.HomeShrSet = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_443 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_443, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_443_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
	& forall NODE_2 : NODE do
			NODE_2 != Other ->
    Sta.Dir.ShrSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_443_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadPtr = Other &
	Sta.Dir.HomeHeadPtr = false &
	Sta.Dir.HomeShrSet = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
	& forall NODE_2 : NODE do
			NODE_2 != Other ->
    Sta.Dir.ShrSet[NODE_2] = false
	end
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;
-- Auxiliary invariants used by NI_Local_GetX_PutX_443: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_344
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadVld = false', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 27 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_344 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_344, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_344_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_344_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false &
	Sta.Dir.Local = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_344: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_245
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadVld = false', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.HomeProc.ProcCmd != NODE_Get', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 27 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_245 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_245, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_245_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_245_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd != NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I;
-- Auxiliary invariants used by NI_Local_GetX_PutX_245: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_PutX_146
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.HomeProc.ProcCmd = NODE_Get', 'Sta.Dir.HeadVld = false', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 27 predicates

include 1 abstract type

Rule NI_Local_GetX_PutX_146 has 1 parameter.

Print abstract rule of NI_Local_GetX_PutX_146, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_PutX_146_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_PutX_146_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false &
	Sta.Dir.Local = true &
	Sta.HomeProc.ProcCmd = NODE_Get
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Local := false ;
	Sta.Dir.Dirty := true ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.Dir.ShrVld := false ;
	for p : NODE do
    Sta.Dir.ShrSet[p] := false ;
	Sta.Dir.InvSet[p] := false ;
	Sta.Dir.HomeShrSet := false ;
	Sta.Dir.HomeInvSet := false ;
	Sta.HomeProc.CacheState := CACHE_I ;
	Sta.HomeProc.InvMarked := true;
-- Auxiliary invariants used by NI_Local_GetX_PutX_146: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_GetX47
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.Dirty = true', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX'}
Strengthening 1 time, find 31 predicates

include 1 abstract type

Rule NI_Local_GetX_GetX47 has 1 parameter.

Print abstract rule of NI_Local_GetX_GetX47, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_GetX47_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HeadPtr != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_GetX47_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HeadPtr != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true;
-- Auxiliary invariants used by NI_Local_GetX_GetX47: 3
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_GetX48
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.Dir.Local = false', 'Sta.Dir.Pending = false', 'Sta.Dir.HomeHeadPtr = true', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX'}
Strengthening 1 time, find 28 predicates

include 1 abstract type

Rule NI_Local_GetX_GetX48 has 1 parameter.

Print abstract rule of NI_Local_GetX_GetX48, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_GetX_GetX48_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HomeHeadPtr = true
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_GetX_GetX48_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HomeHeadPtr = true
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true;
-- Auxiliary invariants used by NI_Local_GetX_GetX48: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_Nak49
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Pending = true'}
Strengthening 1 time, find 18 predicates

include 1 abstract type

Rule NI_Local_GetX_Nak49 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Local_GetX_Nak49: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_Nak50
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.HomeProc.CacheState != CACHE_E', 'Sta.Dir.Local = true', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX'}
Strengthening 1 time, find 26 predicates

include 1 abstract type

Rule NI_Local_GetX_Nak50 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Local_GetX_Nak50: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_GetX_Nak51
guard:{'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.Dir.Local = false', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX', 'Sta.Dir.HomeHeadPtr = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_GetX_Nak51 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Local_GetX_Nak51: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_GetX -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Remote_Get_Put_Home52
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_E', 'Sta.HomeUniMsg.Cmd = UNI_Get', 'Sta.HomeUniMsg.HomeProc = false', 'Sta.HomeUniMsg.Proc = NODE_1'}
Strengthening 1 time, find 42 predicates

include 1 abstract type

Rule NI_Remote_Get_Put_Home52 has 1 parameter.
stmt:Sta.HomeUniMsg.Data := Sta.Proc[NODE_1].CacheData,assign:Sta.Proc[NODE_1].CacheData,rep_dict[assign]:Sta.CurrData
stmt:Sta.HomeUniMsg.Data := Sta.CurrData

Print abstract rule of NI_Remote_Get_Put_Home52, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_Get_Put_Home52_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_Get &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Remote_Get_Put_Home52_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_Get &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.HomeUniMsg.Cmd := UNI_Put ;
	Sta.HomeUniMsg.Data := Sta.CurrData;
-- Auxiliary invariants used by NI_Remote_Get_Put_Home52: 27
string_list:['Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Local = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadVld = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Dirty = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_2']


[Rulename]: NI_Remote_Get_Put53
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_E', 'NODE_2 != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1', 'Sta.UniMsg[NODE_2].HomeProc = false', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get'}
Strengthening 1 time, find 53 predicates

include 2 abstract type

Rule NI_Remote_Get_Put53 has 2 parameter.
stmt:Sta.UniMsg[NODE_2].Data := Sta.Proc[NODE_1].CacheData,assign:Sta.Proc[NODE_1].CacheData,rep_dict[assign]:Sta.CurrData
stmt:Sta.UniMsg[NODE_2].Data := Sta.CurrData
stmt:Sta.ShWbMsg.Data := Sta.Proc[NODE_1].CacheData,assign:Sta.Proc[NODE_1].CacheData,rep_dict[assign]:Sta.CurrData
stmt:Sta.ShWbMsg.Data := Sta.CurrData

Print abstract rule of NI_Remote_Get_Put53, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_Get_Put53_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_Get &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_Get_Put53_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_Get &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.UniMsg[NODE_2].Cmd := UNI_Put ;
	Sta.UniMsg[NODE_2].Data := Sta.CurrData ;
	Sta.ShWbMsg.Cmd := SHWB_ShWb ;
	Sta.ShWbMsg.Proc := NODE_2 ;
	Sta.ShWbMsg.HomeProc := false ;
	Sta.ShWbMsg.Data := Sta.CurrData;

Print abstract rule of NI_Remote_Get_Put53, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_Get_Put53_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.Dir.ShrVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_Get_Put53_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.Dir.ShrVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.ShWbMsg.Cmd := SHWB_ShWb ;
	Sta.ShWbMsg.Proc := Other ;
	Sta.ShWbMsg.HomeProc := false ;
	Sta.ShWbMsg.Data := Sta.CurrData;

Print abstract rule of NI_Remote_Get_Put53, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_Get_Put53_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.ShrVld = false &
		Sta.Dir.HeadVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:
rule "n_ABS_NI_Remote_Get_Put53_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.Proc[NODE_1].CacheData = Sta.CurrData &
		Sta.Proc[NODE_1].ProcCmd != NODE_GetX &
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Proc[NODE_1].CacheState != CACHE_E &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.Dir.Dirty = true &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Nak &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_1].ProcCmd = NODE_None &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.UniMsg[NODE_1].Cmd != UNI_GetX &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_1].ProcCmd != NODE_Get &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Get &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.ShrVld = false &
		Sta.Dir.HeadVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.ShWbMsg.Cmd := SHWB_ShWb ;
	Sta.ShWbMsg.Proc := Other ;
	Sta.ShWbMsg.HomeProc := false ;
	Sta.ShWbMsg.Data := Sta.CurrData;
-- Auxiliary invariants used by NI_Remote_Get_Put53: 63
string_list:['Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.MemData = Sta.CurrData', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Local = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.UniMsg[NODE_1].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.Local = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadVld = true', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Proc[NODE_1].CacheState = CACHE_I', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.UniMsg[NODE_1].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Proc != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.UniMsg[NODE_1].Proc != NODE_2', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.Dirty = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Proc[NODE_1].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Dirty = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Proc[NODE_1].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.ShrSet[NODE_1] = false']


[Rulename]: NI_Remote_Get_Nak_Home54
guard:{'Sta.HomeUniMsg.Cmd = UNI_Get', 'Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.HomeUniMsg.HomeProc = false', 'Sta.HomeUniMsg.Proc = NODE_1'}
Strengthening 1 time, find 6 predicates

include 1 abstract type

Rule NI_Remote_Get_Nak_Home54 has 1 parameter.

Print abstract rule of NI_Remote_Get_Nak_Home54, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_Get_Nak_Home54_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_Get &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Dir.HeadPtr != NODE_1
	end
print_stringAfter:
rule "n_ABS_NI_Remote_Get_Nak_Home54_NODE_1"

	Sta.HomeUniMsg.Cmd = UNI_Get &
	Sta.HomeUniMsg.Proc = Other &
	Sta.HomeUniMsg.HomeProc = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Dir.HeadPtr != NODE_1
	end
action:
	Sta.HomeUniMsg.Cmd := UNI_Nak ;
	Sta.NakcMsg.Cmd := NAKC_Nakc;
-- Auxiliary invariants used by NI_Remote_Get_Nak_Home54: 4
string_list:['Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv']


[Rulename]: NI_Remote_Get_Nak55
guard:{'NODE_2 != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1', 'Sta.UniMsg[NODE_2].HomeProc = false', 'Sta.Proc[NODE_1].CacheState != CACHE_E', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get'}
Strengthening 1 time, find 35 predicates

include 2 abstract type

Rule NI_Remote_Get_Nak55 has 2 parameter.

Print abstract rule of NI_Remote_Get_Nak55, abstract NODE_1
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_Get_Nak55_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_Get &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.HeadVld = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset NODE_2 : NODE do
rule "n_ABS_NI_Remote_Get_Nak55_NODE_1"

	NODE_2 != Other &
	Sta.UniMsg[NODE_2].Cmd = UNI_Get &
	Sta.UniMsg[NODE_2].Proc = Other &
	Sta.UniMsg[NODE_2].HomeProc = false
 	& 
	forall NODE_1 : NODE do
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.HeadVld = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.UniMsg[NODE_2].Cmd := UNI_Nak ;
	Sta.UniMsg[NODE_2].Proc := Other ;
	Sta.UniMsg[NODE_2].HomeProc := false ;
	Sta.NakcMsg.Cmd := NAKC_Nakc;

Print abstract rule of NI_Remote_Get_Nak55, abstract NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_Get_Nak55_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:

ruleset NODE_1 : NODE do
rule "n_ABS_NI_Remote_Get_Nak55_NODE_2"

	Other != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadVld = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.NakcMsg.Cmd := NAKC_Nakc;

Print abstract rule of NI_Remote_Get_Nak55, abstract NODE_1,NODE_2
para_dcit:{'NODE_1': 'NODE', 'NODE_2': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Remote_Get_Nak55_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.HeadVld = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
print_stringAfter:
rule "n_ABS_NI_Remote_Get_Nak55_NODE_1_NODE_2"

	Other != Other
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Proc[NODE_1].InvMarked = false &
		Sta.RpMsg[NODE_2].Cmd != RP_Replace &
		Sta.Dir.Dirty = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_1].Proc != NODE_2 &
		Sta.Proc[NODE_1].CacheState != CACHE_S &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.UniMsg[NODE_1].Cmd != UNI_PutX &
		Sta.InvMsg[NODE_1].Cmd != INV_Inv &
		Sta.MemData = Sta.CurrData &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.Proc[NODE_2].ProcCmd = NODE_Get &
		Sta.Proc[NODE_2].ProcCmd != NODE_GetX &
		Sta.Dir.HeadVld = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.InvMsg[NODE_1].Cmd != INV_InvAck &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Proc != NODE_1 &
		Sta.Dir.InvSet[NODE_1] = false &
		Sta.Dir.ShrSet[NODE_1] = false &
		Sta.UniMsg[NODE_1].Cmd != UNI_Put &
		Sta.Proc[NODE_2].ProcCmd != NODE_None &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck &
		Sta.Proc[NODE_1].CacheState = CACHE_I
	end
action:
	Sta.NakcMsg.Cmd := NAKC_Nakc;
-- Auxiliary invariants used by NI_Remote_Get_Nak55: 39
string_list:['Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.MemData = Sta.CurrData', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.ShrVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.UniMsg[NODE_1].Cmd != UNI_PutX', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.Local = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.Pending = true', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Proc[NODE_1].CacheState = CACHE_I', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.UniMsg[NODE_1].Cmd != UNI_Put', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Proc != NODE_1', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.HeadVld = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Proc[NODE_1].InvMarked = false', 'Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.InvMsg[NODE_1].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.UniMsg[NODE_1].Proc != NODE_2', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.Dirty = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.InvSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 -> Sta.Dir.ShrSet[NODE_1] = false', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Proc[NODE_1].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState != CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.UniMsg[NODE_2].Proc = NODE_1 & Sta.UniMsg[NODE_2].Cmd = UNI_Get -> Sta.Dir.ShrSet[NODE_1] = false']


[Rulename]: NI_Local_Get_Put_Dirty56
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.Dir.Local = true', 'Sta.Dir.Pending = false', 'Sta.HomeProc.CacheState = CACHE_E'}
Strengthening 1 time, find 25 predicates

include 1 abstract type

Rule NI_Local_Get_Put_Dirty56 has 1 parameter.

Print abstract rule of NI_Local_Get_Put_Dirty56, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_Get_Put_Dirty56_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = true &
	Sta.HomeProc.CacheState = CACHE_E
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_Get_Put_Dirty56_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = true &
	Sta.HomeProc.CacheState = CACHE_E
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Dirty := false ;
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false ;
	Sta.MemData := Sta.HomeProc.CacheData ;
	Sta.HomeProc.CacheState := CACHE_S;
-- Auxiliary invariants used by NI_Local_Get_Put_Dirty56: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Put57
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadVld = false', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.Dir.Pending = false', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 26 predicates

include 1 abstract type

Rule NI_Local_Get_Put57 has 1 parameter.

Print abstract rule of NI_Local_Get_Put57, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_Get_Put57_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_Get_Put57_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld = false
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.HeadVld := true ;
	Sta.Dir.HeadPtr := Other ;
	Sta.Dir.HomeHeadPtr := false;
-- Auxiliary invariants used by NI_Local_Get_Put57: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Put_Head58
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.Dir.Pending = false', 'Sta.Dir.HeadVld', 'Sta.Dir.Dirty = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_Get_Put_Head58 has 1 parameter.

Print abstract rule of NI_Local_Get_Put_Head58, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_Get_Put_Head58_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_Get_Put_Head58_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = false &
	Sta.Dir.HeadVld
 	& 
	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.MemData = Sta.CurrData &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.ShrVld := true ;
	for p : NODE do
    if (p = Other) then
      Sta.Dir.InvSet[p] := true ;
	else
      Sta.Dir.InvSet[p] := Sta.Dir.ShrSet[p] ;
	Sta.Dir.HomeInvSet := Sta.Dir.HomeShrSet;
-- Auxiliary invariants used by NI_Local_Get_Put_Head58: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Get59
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.HeadPtr != NODE_1', 'Sta.Dir.Dirty = true', 'Sta.Dir.Local = false', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.Dir.Pending = false'}
Strengthening 1 time, find 31 predicates

include 1 abstract type

Rule NI_Local_Get_Get59 has 1 parameter.

Print abstract rule of NI_Local_Get_Get59, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_Get_Get59_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HeadPtr != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_Get_Get59_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HeadPtr != Other
 	& 
	forall NODE_2 : NODE do
		Sta.Dir.HeadVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true;
-- Auxiliary invariants used by NI_Local_Get_Get59: 6
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Get60
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.Dir.Local = false', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.Dir.Pending = false', 'Sta.Dir.HomeHeadPtr = true'}
Strengthening 1 time, find 28 predicates

include 1 abstract type

Rule NI_Local_Get_Get60 has 1 parameter.

Print abstract rule of NI_Local_Get_Get60, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_NI_Local_Get_Get60_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HomeHeadPtr = true
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_NI_Local_Get_Get60_NODE_1"

	Sta.Dir.Pending = false &
	Sta.Dir.Dirty = true &
	Sta.Dir.Local = false &
	Sta.Dir.HomeHeadPtr = true
 	& 
	forall NODE_2 : NODE; NODE_1 : NODE do
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.Dir.Pending := true;
-- Auxiliary invariants used by NI_Local_Get_Get60: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Nak61
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.Dir.Pending = true', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace'}
Strengthening 1 time, find 17 predicates

include 1 abstract type

Rule NI_Local_Get_Nak61 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Local_Get_Nak61: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Nak62
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.HomeProc.CacheState != CACHE_E', 'Sta.Dir.Local = true'}
Strengthening 1 time, find 25 predicates

include 1 abstract type

Rule NI_Local_Get_Nak62 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Local_Get_Nak62: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Local_Get_Nak63
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Get', 'Sta.UniMsg[NODE_1].HomeProc', 'Sta.Dir.Dirty = true', 'Sta.Dir.Local = false', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace', 'Sta.Dir.HeadPtr = NODE_1', 'Sta.Dir.HomeHeadPtr = false'}
Strengthening 1 time, find 22 predicates

include 1 abstract type

Rule NI_Local_Get_Nak63 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Local_Get_Nak63: 8
string_list:['Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_1', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.Dir.HeadPtr != NODE_2', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_1', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Get -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.RpMsg[NODE_1].Cmd != RP_Replace -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: NI_Nak66
guard:{'Sta.UniMsg[NODE_1].Cmd = UNI_Nak'}
Strengthening 1 time, find 11 predicates

include 1 abstract type

Rule NI_Nak66 has 1 parameter.
action part is empty
-- Auxiliary invariants used by NI_Nak66: 4
string_list:['Sta.UniMsg[NODE_1].Cmd = UNI_Nak -> Sta.Dir.HeadPtr != NODE_2', 'Sta.UniMsg[NODE_1].Cmd = UNI_Nak -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.UniMsg[NODE_1].Cmd = UNI_Nak -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.UniMsg[NODE_1].Cmd = UNI_Nak -> Sta.Dir.HeadPtr != NODE_1']


[Rulename]: PI_Remote_Replace68
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_S', 'Sta.Proc[NODE_1].ProcCmd = NODE_None'}
Strengthening 1 time, find 20 predicates

include 1 abstract type

Rule PI_Remote_Replace68 has 1 parameter.
action part is empty
-- Auxiliary invariants used by PI_Remote_Replace68: 12
string_list:['Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_S -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX']


[Rulename]: PI_Remote_PutX71
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_E', 'Sta.Proc[NODE_1].ProcCmd = NODE_None'}
Strengthening 1 time, find 42 predicates

include 1 abstract type

Rule PI_Remote_PutX71 has 1 parameter.
stmt:Sta.WbMsg.Data := Sta.Proc[NODE_1].CacheData,assign:Sta.Proc[NODE_1].CacheData,rep_dict[assign]:Sta.CurrData
stmt:Sta.WbMsg.Data := Sta.CurrData

Print abstract rule of PI_Remote_PutX71, abstract NODE_1
para_dcit:{'NODE_1': 'NODE'}
print_stringBefore:
rule "n_ABS_PI_Remote_PutX71_NODE_1"

	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:
rule "n_ABS_PI_Remote_PutX71_NODE_1"

	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.WbMsg.Cmd := WB_Wb ;
	Sta.WbMsg.Proc := Other ;
	Sta.WbMsg.HomeProc := false ;
	Sta.WbMsg.Data := Sta.CurrData;
-- Auxiliary invariants used by PI_Remote_PutX71: 31
string_list:['Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Local = false', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadVld = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Dirty = true', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_2']


[Rulename]: PI_Remote_GetX80
guard:{'Sta.Proc[NODE_1].ProcCmd = NODE_None', 'Sta.Proc[NODE_1].CacheState = CACHE_I'}
Strengthening 1 time, find 13 predicates

include 1 abstract type

Rule PI_Remote_GetX80 has 1 parameter.
action part is empty
-- Auxiliary invariants used by PI_Remote_GetX80: 8
string_list:['Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: PI_Remote_Get84
guard:{'Sta.Proc[NODE_1].ProcCmd = NODE_None', 'Sta.Proc[NODE_1].CacheState = CACHE_I'}
Strengthening 1 time, find 13 predicates

include 1 abstract type

Rule PI_Remote_Get84 has 1 parameter.
action part is empty
-- Auxiliary invariants used by PI_Remote_Get84: 8
string_list:['Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].ProcCmd = NODE_None -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_I -> Sta.Dir.HeadPtr != NODE_2']


[Rulename]: Store_Home85
guard:{'Sta.HomeProc.CacheState = CACHE_E'}
Strengthening 1 time, find 0 predicates

include 0 abstract type

Rule Store_Home85 has no parameter.
string_list:[]


[Rulename]: Store86
guard:{'Sta.Proc[NODE_1].CacheState = CACHE_E'}
Strengthening 1 time, find 42 predicates

include 1 abstract type

Rule Store86 has 1 parameter.

Print abstract rule of Store86, abstract NODE_1
para_dcit:{'DATA_1': 'DATA', 'NODE_1': 'NODE'}
print_stringBefore:

ruleset DATA_1 : DATA do
rule "n_ABS_Store86_NODE_1"

	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
print_stringAfter:

ruleset DATA_1 : DATA do
rule "n_ABS_Store86_NODE_1"

	forall NODE_1 : NODE; NODE_2 : NODE do
		Sta.ShWbMsg.Cmd = SHWB_FAck &
		Sta.Dir.HeadVld = true &
		Sta.Dir.HeadPtr != NODE_1 &
		Sta.Proc[NODE_2].CacheState != CACHE_E &
		Sta.UniMsg[NODE_2].Cmd != UNI_PutX &
		Sta.NakcMsg.Cmd != NAKC_Nakc &
		Sta.InvMsg[NODE_2].Cmd != INV_Inv &
		Sta.Proc[NODE_2].CacheState != CACHE_S &
		Sta.WbMsg.Cmd != WB_Wb &
		Sta.Dir.Dirty = true &
		Sta.Dir.Local = false &
		Sta.Dir.HeadPtr != NODE_2 &
		Sta.Dir.Pending = true &
		Sta.Dir.HeadPtr = NODE_1 &
		Sta.Proc[NODE_2].CacheState = CACHE_I &
		Sta.ShWbMsg.Proc = NODE_1 &
		Sta.UniMsg[NODE_2].Cmd != UNI_Put &
		Sta.Dir.InvSet[NODE_2] = false &
		Sta.Dir.ShrSet[NODE_2] = false &
		Sta.UniMsg[NODE_2].Proc != NODE_1 &
		Sta.Dir.ShrVld = false &
		Sta.ShWbMsg.Cmd != SHWB_FAck &
		Sta.Dir.HeadPtr = NODE_2 &
		Sta.ShWbMsg.Proc != NODE_2 &
		Sta.ShWbMsg.Cmd != SHWB_ShWb &
		Sta.Proc[NODE_2].InvMarked = false &
		Sta.InvMsg[NODE_2].Cmd != INV_InvAck
	end
action:
	Sta.CurrData := DATA_1;
-- Auxiliary invariants used by Store86: 27
string_list:['Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_Inv', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_S', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.InvMsg[NODE_2].Cmd != INV_InvAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].InvMarked = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Local = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_PutX', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_ShWb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Cmd != UNI_Put', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadVld = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.WbMsg.Cmd != WB_Wb', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState = CACHE_I', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Proc != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Pending = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd = SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.InvSet[NODE_2] = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.NakcMsg.Cmd != NAKC_Nakc', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_2', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.ShWbMsg.Cmd != SHWB_FAck', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.UniMsg[NODE_2].Proc != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.Dirty = true', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.ShrVld = false', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Proc[NODE_2].CacheState != CACHE_E', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr != NODE_1', 'Sta.Proc[NODE_1].CacheState = CACHE_E -> Sta.Dir.HeadPtr = NODE_2']
checking ./protocols/flash_unde_noaux/ABS_flash_unde_noaux.m

checking invariants...
original_file:./protocols/flash_unde_noaux/ABS_flash_unde_noaux.m
num core = 1, type = <class 'int'>
ranges [(0, 270)]
start:0,end:1
original_file:./protocols/flash_unde_noaux/ABS_flash_unde_noaux.m
new_file:./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m
[call murphi]compile murphi to cpp....
command1 = /home/lyj238/protocol/cmurphi5.4.9.1/cmurphi5.4.9.1/src/mu ./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m
command2 = g++ -ggdb -o ./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.o ./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.cpp -I /home/lyj238/protocol/cmurphi5.4.9.1/cmurphi5.4.9.1/include -lm
command3 = ./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.o -m1000 -finderrors -ndl -m100
compile murphi file to cpp....
Wrong ./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:169: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:200: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:232: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:584: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:623: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:666: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:707: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:748: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:792: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:839: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:885: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:932: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:976: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1021: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1066: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1110: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1146: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1182: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1218: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1248: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1278: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1308: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1525: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1741: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1776: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1844: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:1880: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2043: warning: Scalarset is used in loop index.
	Please make sure that the iterations are independent.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2099:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2137:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2177:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2217:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2330:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2522:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2681:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2686:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2687:NODE_2 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2687:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2687:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2687:Arguments of &, |, -> must be boolean.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2691:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2697:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2697:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2697:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2700:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2700:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2700:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2701:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2701:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2701:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2702:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2702:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2702:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2703:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2704:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2704:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2704:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2705:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2705:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2705:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2706:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2706:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2706:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2708:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2708:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2708:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2709:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2709:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2709:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2712:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2712:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2712:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2713:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2713:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2714:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2721:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2724:Ruleset declaration shadows enclosing Ruleset or Alias.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2726:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2735:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2735:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2735:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2736:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2736:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2736:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2737:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2745:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2753:NODE_1 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2753:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2753:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2753:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2754:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2754:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2754:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2755:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2756:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2756:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2756:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2760:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2760:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2760:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2765:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2776:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2776:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2785:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2791:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2822:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2833:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2833:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2842:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2845:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2866:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2877:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2882:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2891:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2894:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2917:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2928:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2933:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2942:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2945:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2964:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2975:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2980:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2989:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2994:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2995:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2995:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2995:Arguments of &, |, -> must be boolean.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:2999:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3006:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3006:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3006:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3009:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3009:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3009:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3010:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3010:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3010:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3011:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3011:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3011:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3012:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3013:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3013:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3013:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3014:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3014:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3014:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3015:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3015:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3015:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3017:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3017:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3017:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3018:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3018:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3018:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3021:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3021:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3021:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3022:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3022:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3023:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3024:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3040:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3049:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3049:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3049:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3050:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3050:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3050:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3053:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3061:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3070:NODE_1 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3070:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3070:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3070:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3071:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3071:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3071:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3072:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3073:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3073:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3073:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3077:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3077:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3077:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3082:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3093:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3098:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3109:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3115:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3147:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3158:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3163:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3174:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3179:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3180:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3180:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3180:Arguments of &, |, -> must be boolean.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3184:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3191:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3191:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3191:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3194:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3194:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3194:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3195:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3195:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3195:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3196:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3196:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3196:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3197:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3198:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3198:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3198:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3199:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3199:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3199:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3200:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3200:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3200:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3202:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3202:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3202:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3203:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3203:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3203:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3206:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3206:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3206:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3207:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3207:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3208:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3209:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3225:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3234:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3234:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3234:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3235:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3235:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3235:Type of target of assignment doesn't match type of source.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3237:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3245:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3254:NODE_1 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3254:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3254:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3254:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3255:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3255:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3255:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3256:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3257:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3257:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3257:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3261:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3261:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3261:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3266:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3277:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3282:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3292:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3298:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3330:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3341:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3346:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3356:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3359:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3381:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3392:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3397:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3408:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3411:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3433:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3444:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3449:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3459:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3462:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3486:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3497:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3502:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3513:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3516:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3536:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3547:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3552:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3563:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3566:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3590:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3601:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3606:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3616:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3619:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3639:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3650:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3655:syntax error. Last token read was ')'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3665:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3668:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3675:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3692:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3709:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3717:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3734:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3751:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3759:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3776:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3794:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3815:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3832:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3854:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3871:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3893:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3911:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3934:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3940:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3961:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:3979:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4012:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4021:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4022:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4022:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4022:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4023:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4023:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4023:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4024:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4024:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4025:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4027:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4027:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4027:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4032:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4032:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4032:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4033:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4033:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4033:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4035:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4035:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4035:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4036:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4036:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4036:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4041:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4044:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4044:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4044:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4046:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4046:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4046:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4047:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4047:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4047:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4048:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4048:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4048:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4049:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4049:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4050:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4050:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4051:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4051:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4051:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4056:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4057:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4057:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4057:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4058:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4060:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4060:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4060:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4061:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4061:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4062:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4063:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4080:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4082:NODE_1 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4082:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4082:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4082:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4083:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4083:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4083:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4084:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4084:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4084:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4087:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4087:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4087:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4089:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4090:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4090:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4090:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4091:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4091:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4091:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4094:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4094:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4094:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4095:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4095:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4095:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4099:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4099:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4099:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4101:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4101:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4101:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4103:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4104:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4104:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4104:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4105:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4106:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4106:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4106:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4108:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4109:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4109:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4109:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4111:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4111:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4111:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4114:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4114:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4115:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4115:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4116:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4116:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4116:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4119:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4119:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4120:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4121:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4134:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4190:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4199:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4209:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4218:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4219:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4219:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4219:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4220:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4220:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4220:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4221:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4221:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4222:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4224:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4224:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4224:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4227:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4227:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4227:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4229:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4229:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4229:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4230:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4230:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4230:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4234:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4236:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4236:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4236:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4237:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4237:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4237:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4238:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4238:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4238:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4240:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4240:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4242:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4242:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4245:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4245:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4245:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4247:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4247:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4248:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4249:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4264:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4266:NODE_1 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4266:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4266:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4266:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4268:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4269:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4269:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4269:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4270:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4270:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4270:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4273:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4273:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4273:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4274:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4274:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4274:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4280:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4281:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4281:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4281:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4284:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4284:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4285:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4285:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4286:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4286:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4286:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4288:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4288:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4289:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4290:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4300:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4337:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4343:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4363:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4374:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4394:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4402:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4419:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4423:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4428:syntax error. Last token read was 'endrule'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4431:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4454:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4460:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4481:syntax error. Last token read was '==>'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4508:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4510:NODE_1 undeclared.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4510:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4511:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4511:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4511:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4512:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4512:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4512:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4514:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4514:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4514:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4515:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4515:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4515:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4519:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4521:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4522:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4522:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4522:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4523:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4524:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4524:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4524:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4525:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4525:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4526:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4526:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4527:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4527:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4530:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4531:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4533:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4533:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4533:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4534:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4534:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4535:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4535:syntax error. Last token read was 'end'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4556:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4558:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4559:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4559:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4559:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4560:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4560:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4560:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4562:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4562:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4562:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4563:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4563:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4563:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4567:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4569:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4570:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4570:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4570:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4571:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4572:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4572:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4572:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4573:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4573:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4574:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4574:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4575:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4575:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4578:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4579:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4581:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4581:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4581:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4582:Wrong index type for array reference.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4582:Not a record type.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4583:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4583:syntax error. Last token read was 'end'
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4594:Arguments of = or <> must have same types.
./protocols/flash_unde_noaux/ABS_flash_unde_noaux_1.m:4594:syntax error. Last token read was ')'

Traceback (most recent call last):
  File "main.py", line 533, in <module>
    sys.exit(main(sys.argv[1:]))
  File "main.py", line 521, in main
    all(data_dir, args, murphi_url, recalculate=args.recalculate == 'y')
  File "main.py", line 477, in all
    cmp(data_dir, args, all_types, aux_invs, abs_filename, prot_analyzer)
  File "main.py", line 297, in cmp
    counterex_index = checker.check_usedF(used_inv_string_list, 1, abs_filename,
  File "/home/lyj238/protocol/project/association_rule_learning/select_invs.py", line 219, in check_usedF
    spurious_cnt, counterex_index = self.select_invariant(test_rule_string, keep_file=keep_file, num_core=num_core,
  File "/home/lyj238/protocol/project/association_rule_learning/select_invs.py", line 57, in select_invariant
    spurious_index.extend(self.parallel(len(jobs), 1, translate_dic, original_file, keep_file, aux_para))
  File "/home/lyj238/protocol/project/association_rule_learning/select_invs.py", line 102, in parallel
    counter_ex_list = run_murphi_all(self.data_dir, self.name, 'ABS_{0}_{1}'.format(self.name, id), self.murphi_dir, aux_para)
  File "/home/lyj238/protocol/project/murphi_analysis/call_murphi.py", line 84, in run_murphi_all
    raise ValueError
ValueError
